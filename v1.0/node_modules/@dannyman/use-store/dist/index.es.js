import { useCallback, useState, useEffect, useLayoutEffect } from 'react';

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// Private Functions
var isSameType = function isSameType(value1, value2) {
  return _typeof(value1) === _typeof(value2);
};

var isNumber = function isNumber(value) {
  return !isNaN(value);
};

var isArray = function isArray(value) {
  return Array.isArray(value);
};

var isObject = function isObject(value) {
  return _typeof(value) === 'object';
};

var isString = function isString(value) {
  return typeof value === 'string';
};

var isTheSameObject = function isTheSameObject(object1, object2) {
  return JSON.stringify(Object.values(object1).sort()) === JSON.stringify(Object.values(object2).sort());
};

var isTheSameArray = function isTheSameArray(arr1, arr2) {
  return arr1 && arr2 && arr1.length === arr2.length && arr1.every(function (value1) {
    return arr2.some(function (value2) {
      return isTheSameObject(value1, value2);
    });
  });
};

var isNullOrUndefined = function isNullOrUndefined(value) {
  return typeof value === 'undefined' || value === null;
};

var isFunction = function isFunction(value) {
  return typeof value === 'function';
}; // Consts


var ssrStateMock = [false, function () {
  return false;
}];
var isBrowser = typeof window !== 'undefined';
var validations = {
  isSameType: isSameType,
  isNumber: isNumber,
  isArray: isArray,
  isObject: isObject,
  isString: isString,
  isTheSameObject: isTheSameObject,
  isTheSameArray: isTheSameArray,
  isNullOrUndefined: isNullOrUndefined,
  isFunction: isFunction
}; // Public Functions

var set = function set(storage, key, value) {
  return storage.setItem(key, btoa(JSON.stringify(value)));
};

var get = function get(storage, key) {
  var raw = storage.getItem(key);
  return raw && raw.length ? JSON.parse(atob(raw)) : false;
};

var refresh = function refresh(callback) {
  return setInterval(callback, 500);
};

var getValidOptions = function getValidOptions(options) {
  return {
    autoRefresh: (options === null || options === void 0 ? void 0 : options.autoRefresh) || false,
    debug: (options === null || options === void 0 ? void 0 : options.debug) || false,
    isNew: (options === null || options === void 0 ? void 0 : options.isNew) || false
  };
};

var stateShouldUpdate = function stateShouldUpdate(state, newState) {
  switch (true) {
    case !isSameType(state, newState):
    case isObject(newState) && !isNullOrUndefined(newState) && !isTheSameObject(state, newState):
    case isArray(newState) && !isTheSameArray(state, newState):
    case (isString(newState) || isNumber(newState)) && state !== newState:
      return true;

    default:
      return false;
  }
};

var writeToLog = function writeToLog(debug, key) {
  return debug ? function (message) {
    var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
    var err = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    console.group("[@dannyman/use-store]@%c".concat(key), 'color: blue;');
    if (message) console.log("".concat(err ? '%cERROR: ' : '%c').concat(message), "color: ".concat(err ? 'red' : 'green', ";"));
    if (!isFunction(object)) console.log("".concat(_typeof(object), " =>"), JSON.parse(JSON.stringify(object)));
    console.groupEnd();
  } : function () {};
};

var isSSR = function isSSR() {
  return !isBrowser ? ssrStateMock : false;
};

var handleState = function handleState(storage, key) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var options = arguments.length > 3 ? arguments[3] : undefined;

  var _getValidOptions = getValidOptions(options),
      autoRefresh = _getValidOptions.autoRefresh,
      isNew = _getValidOptions.isNew,
      debug = _getValidOptions.debug;

  var log = useCallback(writeToLog(debug, key));

  var _useState = useState(function () {
    if (validations.isFunction(defaultValue)) {
      log('The defaultValue cannot be a function.', defaultValue, true);
      defaultValue = false;
    }

    var existentValue = get(storage, key);

    var _defaultValue = !isNew ? existentValue !== null ? existentValue : defaultValue : defaultValue;

    log('Default Value:', _defaultValue);
    return _defaultValue;
  }),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  useEffect(function () {
    log('Updated value:', state);
    set(storage, key, state);
  }, [key, state]);
  useLayoutEffect(function () {
    if (autoRefresh) {
      var interval = refresh(function () {
        var newState = get(storage, key);

        if (stateShouldUpdate(state, newState)) {
          log('Auto refresh updating.');
          setState(newState);
        }
      });
      return function () {
        return clearInterval(interval);
      };
    }
  }, [state]);
  return [state, setState];
}; // Public functions


var usePersistedState = function usePersistedState(key, defaultValue, options) {
  return isSSR() || handleState(localStorage, key, defaultValue, options);
};

var useSessionState = function useSessionState(key, defaultValue, options) {
  return isSSR() || handleState(sessionStorage, key, defaultValue, options);
}; // Exports

export { usePersistedState, useSessionState };
//# sourceMappingURL=index.es.js.map
